<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éƒ½ä¾†ç©ï¼èªæ³•æ¶ˆæ¶ˆæ¨‚</title>
    <style>
        /* ------------------------------------- */
        /* --- åŸºç¤æ¨£å¼èˆ‡æ–‡å­—é¸å–ç¦ç”¨ --- */
        /* ------------------------------------- */
        body {
            font-family: 'å¾®è»Ÿæ­£é»‘é«”', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f8ff;
            padding: 20px;
            /* ç¦ç”¨æ‰€æœ‰æ–‡å­—é¸å– */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            /* ğŸš€ é—œéµï¼šé˜²æ­¢æ‰‹æ©Ÿé è¨­æ»‘å‹•/ç¸®æ”¾ */
            touch-action: none; 
        }

        h1 { color: #4682b4; }
        #prompt { font-size: 16px; margin-bottom: 5px; color: #ff4500; font-weight: bold; }
        #instruction { margin-bottom: 15px; color: #333; font-size: 14px; }

        /* --- éŠæˆ²ç¶²æ ¼èˆ‡æ–¹å¡Šæ¨£å¼ (æ¡Œé¢é€šç”¨) --- */
        #game-board {
            display: grid;
            grid-template-columns: repeat(4, 75px);
            grid-template-rows: repeat(4, 75px);
            gap: 4px;
            padding: 15px;
            background-color: #add8e6;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .tile {
            width: 75px;
            height: 75px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 16px;
            font-weight: bold;
            color: #333;
            background-color: #fff;
            border: 2px solid #ccc;
            border-radius: 8px;
            cursor: grab;
            transition: opacity 0.3s, transform 0.1s;
            user-select: none;
        }

        /* æ ¸å¿ƒæ–¹å¡Šé¡è‰²å®šç¾© */
        .dou { background-color: #ffd700 !important; border: 3px solid #ff8c00 !important; } /* éƒ½ (é»ƒè‰²) */
        .subject, .complement { background-color: #b0e0e6; } /* ä¸»è©/åè©é¡ (è—è‰²) */
        .verb { background-color: #f08080; } /* å‹•è© (ç´…è‰²) */
        .connector { background-color: #98fb98; } /* å’Œ (ç¶ è‰²) */

        /* è¢«æ‹–æ›³ç‹€æ…‹ */
        .dragging { opacity: 0.5; transform: scale(1.05); }
        .hidden { visibility: hidden; }

        /* --- ä¸‹æ–¹å¡«ç©ºæ¬„ä½ (6å€‹æ¬„ä½) --- */
        #sentence-slots {
            display: flex;
            margin-top: 30px;
            margin-bottom: 20px;
            width: 480px;
            justify-content: space-around;
        }

        .slot {
            width: 75px;
            height: 75px;
            border: 2px dashed #4682b4;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .slot-tile {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
        }

        .slot-end {
            width: 30px;
            height: 75px;
            border: none;
            font-size: 40px;
            font-weight: bold;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }

        /* --- æŒ‰éˆ•èˆ‡ç‹€æ…‹ --- */
        #controls { margin-top: 15px; }
        .control-button {
            padding: 12px 25px;
            font-size: 18px;
            margin: 0 10px;
            cursor: pointer;
            border-radius: 5px;
        }

        #check-button { background-color: #008000; color: white; border: none; }
        #check-button:hover { background-color: #006400; }

        #message-box {
            margin-top: 20px;
            font-size: 20px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            min-height: 40px;
        }
        .correct { color: white; background-color: #28a745; }
        .wrong { color: white; background-color: #dc3545; }

        /* ------------------------------------- */
        /* ğŸš€ å°è¢å¹•ï¼ˆæ‰‹æ©Ÿï¼‰åª’é«”æŸ¥è©¢å„ªåŒ– */
        /* ------------------------------------- */
        @media (max-width: 500px) {
            body {
                padding: 10px;
            }

            #game-board {
                grid-template-columns: repeat(4, 65px); /* é€²ä¸€æ­¥ç¸®å° */
                grid-template-rows: repeat(4, 65px);
                gap: 3px;
                padding: 10px;
            }

            .tile {
                width: 65px;
                height: 65px;
                font-size: 14px;
            }

            #sentence-slots {
                margin-top: 20px;
                /* ä¿æŒå–®è¡Œä½ˆå±€ï¼Œè®“æ‰‹æ©Ÿç”¨æˆ¶å¯ä»¥æ‹–æ›³åˆ°ç›®æ¨™ */
                width: 100%; 
            }

            .slot {
                width: 65px;
                height: 65px;
                margin: 0 2px;
            }

            .slot-end {
                height: 65px;
                font-size: 30px;
            }

            #message-box {
                font-size: 16px;
                padding: 8px;
            }
        }
    </style>
</head>
<body>

    <h1>éƒ½ä¾†ç©ï¼èªæ³•æ¶ˆæ¶ˆæ¨‚</h1>
    <div id="prompt">è«‹çµ„å‡ºä¸€å€‹ç”±**å…­å€‹**æ–¹å¡Šçµ„æˆçš„å®Œæ•´å¥å­ï¼Œå¡«å…¥ä¸‹æ–¹æ¬„ä½ã€‚</div>
    <div id="instruction">æç¤ºï¼šå°‡æ–¹å¡Š**æ‹–æ›³**è‡³ä¸‹æ–¹çš„æ¬„ä½ä¸­ã€‚é»æ“Šä¸‹æ–¹æ¬„ä½ä¸­çš„æ–¹å¡Šå¯å–æ¶ˆã€‚</div>
    <div id="instruction">ä¾‹å¥ï¼šæˆ‘å’Œä½ éƒ½è½éŸ³æ¨‚ã€‚</div>


    <div id="game-board">
    </div>

    <div id="sentence-slots">
        <div class="slot" id="slot-0"></div>
        <div class="slot" id="slot-1"></div>
        <div class="slot" id="slot-2"></div>
        <div class="slot" id="slot-3"></div>
        <div class="slot" id="slot-4"></div>
        <div class="slot" id="slot-5"></div>
        <div class="slot-end">ã€‚</div>
    </div>

    <div id="controls">
        <button id="check-button" class="control-button">å®Œæˆ</button>
    </div>

    <div id="message-box"></div>

    <script>
        // --- éŠæˆ²æ•¸æ“šèˆ‡è¨­å®š ---
        const GRID_SIZE = 16;
        const SENTENCE_LENGTH = 6;
        const boardElement = document.getElementById('game-board');
        const messageBox = document.getElementById('message-box');
        const checkButton = document.getElementById('check-button');

        // ğŸš€ æ–°å¢å…¨åŸŸè®Šæ•¸ï¼Œç”¨æ–¼æ‰‹æ©Ÿæ‹–æ›³å„ªåŒ–
        let draggedTile = null;
        let currentSlot = null; // ç”¨æ–¼è·Ÿè¹¤ç•¶å‰æ‰‹æŒ‡æ‰€åœ¨çš„æ§½ä½

        // P: äººç‰©, D: é£²æ–™, S: é‹å‹•é …ç›®
        const vocabCategories = {
            'P': ['æˆ‘', 'ä½ ', 'ä»–', 'çˆ¸çˆ¸', 'åª½åª½', 'å§Šå§Š', 'å¦¹å¦¹', 'å“¥å“¥'],
            'D': ['å’–å•¡', 'çƒé¾èŒ¶'],
            'S': ['æ£’çƒ', 'ç¶²çƒ', 'ç±ƒçƒ', 'æ¸¸æ³³'],
            'CONNECTOR': ['å’Œ'],
            'DOU': ['éƒ½'],
            'VERB_GENERIC': ['å–œæ­¡', 'å­¸', 'è½', 'çœ‹', 'è¦ºå¾—'],
            'VERB_ACTION': ['æ‰“'],
            'ADJ_VERB': ['å¥½'],
            'COMPLEMENT_MUSIC': ['éŸ³æ¨‚'], 
            'COMPLEMENT': ['é›»å½±', 'é‹å‹•', 'æ¼‚äº®', 'å¥½ç©', 'ç©', 'å–', 'èŒ¶', 'çœ‹', 'è½']
        };

        // è¼”åŠ©å‡½æ•¸ï¼šæ ¹æ“šè©å½™ç²å–å…¶èªæ³•é¡åˆ¥
        function getVocabCategory(word) {
            for (const category in vocabCategories) {
                if (vocabCategories[category].includes(word)) {
                    return category;
                }
            }
            return 'OTHER';
        }

        // çµåˆæ‰€æœ‰è©å½™å’Œå®ƒå€‘çš„é¡è‰²é¡å‹
        const allVocab = [];
        for (const cat in vocabCategories) {
            const colorType = (cat === 'P' || cat === 'D' || cat === 'S' || cat === 'COMPLEMENT' || cat === 'COMPLEMENT_MUSIC') ? 'subject' :
                              (cat.startsWith('VERB') || cat === 'ADJ_VERB') ? 'verb' :
                              (cat === 'CONNECTOR') ? 'connector' :
                              (cat === 'DOU') ? 'dou' : 'complement';

            vocabCategories[cat].forEach(word => {
                allVocab.push({ text: word, type: colorType });
            });
        }

        // --- å¥å‹æ¨¡æ¿è¦å‰‡ ---
        const sentenceTemplates = [
            // P å’Œ P éƒ½ C D (äºº + å‹•ä½œ)
            { A_TYPE: 'P', B_TYPE: 'P', C: 'å–œæ­¡', D_CAT: ['S', 'D', 'COMPLEMENT', 'COMPLEMENT_MUSIC'] },
            { A_TYPE: 'P', B_TYPE: 'P', C: 'å­¸', D_CAT: ['S', 'COMPLEMENT'] },
            { A_TYPE: 'P', B_TYPE: 'P', C: 'æ‰“', D_CAT: ['S'] }, // æ‰“ -> æ£’çƒ/ç¶²çƒ/ç±ƒçƒ
            { A_TYPE: 'P', B_TYPE: 'P', C: 'è½', D_CAT: ['COMPLEMENT_MUSIC'] }, // è½ -> éŸ³æ¨‚
            { A_TYPE: 'P', B_TYPE: 'P', C: 'çœ‹', D_WORD: ['é›»å½±'] }, // çœ‹ -> é›»å½±
            { A_TYPE: 'P', B_TYPE: 'P', C: 'å¥½', D_CAT: ['COMPLEMENT'], D_WORD: ['æ¼‚äº®'] }, // äºº + å¥½ + æ¼‚äº®
            { A_TYPE: 'P', B_TYPE: 'P', C: 'è¦ºå¾—', D_CAT: ['COMPLEMENT'] },

            // D å’Œ D éƒ½ å¥½ D (éäººç¨± + è©•åƒ¹)
            { A_TYPE: 'D', B_TYPE: 'D', C: 'å¥½', D_CAT: ['COMPLEMENT'], D_WORD: ['å–'] }, // é£²æ–™ + å¥½ + å–
            { A_TYPE: 'S', B_TYPE: 'S', C: 'å¥½', D_CAT: ['COMPLEMENT'], D_WORD: ['ç©'] }, // é‹å‹• + å¥½ + ç©
            { A_TYPE: 'COMPLEMENT', B_TYPE: 'COMPLEMENT', C: 'å¥½', D_CAT: ['COMPLEMENT'], D_WORD: ['çœ‹', 'ç©'] }, // é›»å½±/é‹å‹• + å¥½ + çœ‹/ç©
            { A_TYPE: 'COMPLEMENT_MUSIC', B_TYPE: 'COMPLEMENT_MUSIC', C: 'å¥½', D_CAT: ['COMPLEMENT'], D_WORD: ['è½'] }, // éŸ³æ¨‚ + å¥½ + è½
        ];

        const validSubjectCategories = ['P', 'D', 'S', 'COMPLEMENT', 'COMPLEMENT_MUSIC'];

        let currentTiles = [];
        let slotContents = Array(SENTENCE_LENGTH).fill(null);
        let eliminatedSentences = new Set();
        // draggedTile ç§»åˆ°æœ€ä¸Šæ–¹ï¼Œå·²å®šç¾©

        // å¹«æ‰‹å‡½æ•¸ï¼šæ‰“äº‚é™£åˆ—
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // é—œéµè©å½™ç”Ÿæˆé‚è¼¯ (ä¿æŒä¸è®Š)
        function getRandomSubjectGroup(existingVocabSet) {
            const groups = ['P', 'D', 'S'];
            const mainType = groups[Math.floor(Math.random() * groups.length)];
            
            let requiredWords = new Set();
            let mainVocabList = vocabCategories[mainType];
            
            let uniqueSubjects = shuffleArray([...mainVocabList]);
            if (uniqueSubjects.length >= 2) {
                requiredWords.add(uniqueSubjects[0]);
                requiredWords.add(uniqueSubjects[1]);
            } else if (uniqueSubjects.length === 1) {
                requiredWords.add(uniqueSubjects[0]);
                requiredWords.add(uniqueSubjects[0]);
            }

            const possibleTemplates = sentenceTemplates.filter(t => t.A_TYPE === mainType);
            if (possibleTemplates.length > 0) {
                const template = possibleTemplates[Math.floor(Math.random() * possibleTemplates.length)];
                requiredWords.add(template.C);
                
                // æ‰¾åˆ°èˆ‡æ¨¡æ¿åŒ¹é…çš„ D_WORD
                const allComplement = vocabCategories.COMPLEMENT.concat(vocabCategories.S, vocabCategories.D, vocabCategories.COMPLEMENT_MUSIC).filter(w => !requiredWords.has(w));
                
                let dWord;
                
                if (template.D_WORD) {
                    dWord = template.D_WORD[Math.floor(Math.random() * template.D_WORD.length)];
                } else {
                    const potentialD = allComplement.filter(w => template.D_CAT.includes(getVocabCategory(w)));
                    dWord = potentialD.length > 0 ? potentialD[Math.floor(Math.random() * potentialD.length)] : vocabCategories.COMPLEMENT[0];
                }
                
                requiredWords.add(dWord);
            }

            return Array.from(requiredWords).filter(w => !existingVocabSet.has(w));
        }

        // --- 1. éŠæˆ²åˆå§‹åŒ– ---

        function initializeGame() {
            boardElement.innerHTML = '';
            messageBox.textContent = '';
            messageBox.className = '';
            checkButton.disabled = false;
            eliminatedSentences.clear();
            
            refillBoard(true);
            initializeSlots();
            checkButton.onclick = checkSentence;
        }

        // è£œå……æ–°æ–¹å¡Šä¸¦é‡æ–°ä½ˆå±€ (ä¿æŒä¸è®Š)
        function refillBoard(isInitial = false) {
            currentTiles = Array.from(boardElement.children);
            let existingVocab = currentTiles.map(tile => tile.dataset.text);
            let vocabSet = new Set(existingVocab);

            let requiredNext = ['éƒ½', 'å’Œ'];
            requiredNext.forEach(word => {
                if (!vocabSet.has(word)) {
                    existingVocab.push(word);
                    vocabSet.add(word);
                }
            });

            let seedWords = getRandomSubjectGroup(vocabSet);
            seedWords.forEach(word => {
                if (!vocabSet.has(word)) {
                    existingVocab.push(word);
                    vocabSet.add(word);
                }
            });
            
            let needToFill = GRID_SIZE - existingVocab.length;
            
            const allVocabTexts = allVocab.map(v => v.text);
            
            if (needToFill > 0) {
                let availableFillers = shuffleArray(allVocabTexts.filter(w => !vocabSet.has(w)));
                let fillerIndex = 0;

                for (let i = 0; i < needToFill; i++) {
                    let randomVocab;
                    if (availableFillers.length > fillerIndex) {
                        randomVocab = availableFillers[fillerIndex];
                        fillerIndex++;
                    } else {
                        randomVocab = allVocabTexts[Math.floor(Math.random() * allVocabTexts.length)];
                    }
                    existingVocab.push(randomVocab);
                }
            }
            
            existingVocab = existingVocab.slice(0, GRID_SIZE);

            boardElement.innerHTML = '';
            let newTilesVocab = shuffleArray(existingVocab);
            currentTiles = [];
            
            newTilesVocab.forEach(text => {
                const vocabDef = allVocab.find(v => v.text === text);
                createTile(text, vocabDef ? vocabDef.type : 'subject');
            });
        }
        
        // ğŸš€ ä¿®æ”¹ï¼šåˆå§‹åŒ–ä¸‹æ–¹æ‹–æ›³æ¬„ä½ (ç§»é™¤ ondrop)
        function initializeSlots() {
            slotContents.fill(null);
            for(let i = 0; i < SENTENCE_LENGTH; i++) {
                const slot = document.getElementById(`slot-${i}`);
                slot.innerHTML = '';
                // æ¡Œé¢æ‹–æ›³å¿…è¦
                slot.ondragover = (e) => e.preventDefault(); 
                // **ç§»é™¤ slot.ondrop = ... ä»¥ä¾¿è®“æ‰‹æ©Ÿè§¸æ§è™•ç†æ”¾ç½®é‚è¼¯**
            }
        }

        // --- 2. æ‹–æ›³èˆ‡å¾©åŸé‚è¼¯ (æ•´åˆæ¡Œé¢èˆ‡æ‰‹æ©Ÿå„ªåŒ–) ---

        // ğŸš€ é—œéµï¼šæ–°å¢ setupDragEvents å‡½æ•¸ä¾†è™•ç†æ‰€æœ‰äº‹ä»¶
        function setupDragEvents(tile) {
            // --- æ¡Œé¢ç‰ˆï¼ˆDrag Eventsï¼‰ ---
            tile.ondragstart = (e) => {
                draggedTile = tile;
                e.dataTransfer.setData('text/plain', tile.dataset.text);
                setTimeout(() => tile.classList.add('dragging'), 0);
            };

            tile.ondragend = () => {
                tile.classList.remove('dragging');
                draggedTile = null;
                currentSlot = null; // é‡ç½®
            };

            // --- æ‰‹æ©Ÿç‰ˆï¼ˆTouch Eventsï¼‰æ–°å¢å„ªåŒ– ---

            // 1. è§¸æ‘¸é–‹å§‹ (touchstart): æº–å‚™æ‹–æ›³ä¸¦é˜»æ­¢é é¢æ»¾å‹•
            tile.ontouchstart = (e) => {
                // é˜»æ­¢ç€è¦½å™¨è™•ç†è§¸æ‘¸ï¼ˆé˜²æ­¢é é¢æ»¾å‹•æˆ–ç¸®æ”¾ï¼‰
                e.preventDefault(); 
                
                draggedTile = tile;
                tile.classList.add('dragging');

                // æ¨¡æ“¬æ‹–æ›³ï¼Œå°‡æ–¹å¡Šéš±è—
                // æ³¨æ„ï¼šé€™è£¡ä½¿ç”¨ setTimeout ç¢ºä¿éš±è—ç™¼ç”Ÿåœ¨ä¸‹ä¸€å¹€ï¼Œè®“æ‹–æ›³æ‰‹æ„Ÿæ›´å¥½
                setTimeout(() => tile.classList.add('hidden'), 50); 
            };

            // 2. è§¸æ‘¸ç§»å‹• (touchmove): è¿½è¹¤æ‰‹æŒ‡ä½ç½®ä¸¦é«˜äº®ç›®æ¨™æ§½ä½
            tile.ontouchmove = (e) => {
                if (!draggedTile) return;
                
                e.preventDefault(); // å†æ¬¡é˜»æ­¢é é¢æ»¾å‹•

                // ç²å–æ‰‹æŒ‡åœ¨è¢å¹•ä¸Šçš„ä½ç½®
                const touch = e.touches[0];
                
                // åµæ¸¬æ‰‹æŒ‡ä¸‹æ–¹æ˜¯å¦æœ‰ç›®æ¨™å…ƒç´  (slot)
                const targetElement = document.elementFromPoint(touch.clientX, touch.clientY);
                
                const slots = document.querySelectorAll('.slot');
                let newSlot = null;

                slots.forEach(slot => {
                    const slotIndex = parseInt(slot.id.split('-')[1]);
                    // æª¢æŸ¥ç›®æ¨™å…ƒç´ æ˜¯å¦ç‚º slot æœ¬èº«æˆ– slot å…§éƒ¨çš„å…ƒç´ ï¼Œä¸” slot ç‚ºç©º
                    if (slot.contains(targetElement) && slotContents[slotIndex] === null) {
                        newSlot = slot;
                    }
                });
                
                // è™•ç†é«˜äº®æ•ˆæœ (å¯é¸ï¼Œä½†æœ‰åŠ©æ–¼ç”¨æˆ¶é«”é©—)
                if (newSlot !== currentSlot) {
                    if (currentSlot) {
                        currentSlot.style.backgroundColor = ''; // æ¸…é™¤èˆŠé«˜äº®
                    }
                    if (newSlot) {
                        newSlot.style.backgroundColor = '#e0f7fa'; // æ–°é«˜äº®
                    }
                    currentSlot = newSlot;
                }
            };

            // 3. è§¸æ‘¸çµæŸ (touchend): æ”¾ç½®æ–¹å¡Š
            tile.ontouchend = (e) => {
                if (!draggedTile) return;
                
                draggedTile.classList.remove('dragging');
                draggedTile.classList.remove('hidden'); // å…ˆé¡¯ç¤ºå›ä¾†

                // å¦‚æœç•¶å‰æœ‰é«˜äº®æ§½ä½ï¼ŒåŸ·è¡Œæ”¾ç½®é‚è¼¯
                if (currentSlot) {
                    const slotIndex = parseInt(currentSlot.id.split('-')[1]);
                    
                    if (slotContents[slotIndex] === null) {
                        // æ‰‹å‹•è§¸ç™¼æ”¾ç½®é‚è¼¯
                        handleDropManual(draggedTile, slotIndex);
                    }
                }
                
                // æ¸…é™¤æ‰€æœ‰é«˜äº®ä¸¦é‡ç½®ç‹€æ…‹
                document.querySelectorAll('.slot').forEach(slot => slot.style.backgroundColor = '');
                draggedTile = null;
                currentSlot = null;
            };

             // æ¡Œé¢æ‹–æ›³æ”¾ç½®è™•ç† (ä¿ç•™ï¼Œç”¨æ–¼æ¡Œé¢ç€è¦½å™¨)
            tile.addEventListener('drop', (e) => {
                e.preventDefault();
                const slotIndex = parseInt(e.currentTarget.id.split('-')[1]);
                handleDrop(e, slotIndex);
            });
        }


        // ğŸš€ ä¿®æ”¹ï¼šå‰µå»ºæ–¹å¡Šçš„å‡½æ•¸ (èª¿ç”¨ setupDragEvents)
        function createTile(text, type) {
            const tile = document.createElement('div');
            tile.className = `tile ${type}`;
            tile.textContent = text;
            tile.dataset.text = text;
            tile.setAttribute('draggable', true);
            tile.dataset.originalType = type;

            setupDragEvents(tile); // æ‡‰ç”¨æ–°çš„äº‹ä»¶è™•ç†é‚è¼¯

            boardElement.appendChild(tile);
            currentTiles.push(tile);
            return tile;
        }

        // æ¡Œé¢æ‹–æ›³æ”¾ç½®è™•ç† (ä¿ç•™åŸå§‹é‚è¼¯ï¼Œç”¨æ–¼æ¡Œé¢)
        function handleDrop(e, slotIndex) {
            e.preventDefault();
            if (!draggedTile || slotContents[slotIndex] !== null) return;

            const text = draggedTile.dataset.text;
            const originalTile = draggedTile;

            const vocabItem = allVocab.find(v => v.text === text);
            const type = vocabItem ? vocabItem.type : 'subject';
            
            slotContents[slotIndex] = { text, originalTile, type
